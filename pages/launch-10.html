<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Электронный учебник</title>
    <link rel="stylesheet" href="../main.css">
    <link rel="stylesheet" href="img/transparter.png">
</head>
<body>
  <header class="header">
    <nav class="container header-nav">
        <a href="#" class="header-logo">
            <img class="img" src="../img/Group 5.svg" alt="logo">
        </a>
        <div class="header-count">
    <a href="sign-in.html" class="header-link" href="#">Войти</a>
    <a href="registration.html" class="header-link" href="#">Регистрация</a>    
    </div>
    </nav>
    
        
            <h1 class="block-info-p block-info-text-p">Добро пожаловать в учебник JavaScript!</h1>
        
</header>
    <main class="main">
    <div class="block-left">
        <ul>
          <a href="start.html" class="menu-left">Введение</a>
            <a href="launch.html" class="menu-left">Запуск программы</a>
            <a href="launch-2.html" class="menu-left">Переменные</a>
            <a href="launch-3.html" class="menu-left">Типы данных</a>
            <a href="launch-4.html" class="menu-left">Математические операции</a>
            <a href="launch-5.html" class="menu-left">Строки</a>
            <a href="launch-6.html" class="menu-left">Условия</a>
            <a href="launch-7.html" class="menu-left">Функции</a>
            <a href="launch-8.html" class="menu-left">Циклы</a>
            <a href="launch-9.html" class="menu-left">Массивы</a>
            <a href="launch-10.html" class="menu-left">Объекты</a>
            <a href="launch-11.html" class="menu-left">Методы чисел</a>
            <a href="launch-12.html" class="menu-left">Методы строк</a>
            <a href="launch-13.html" class="menu-left">Методы функций</a>
            <a href="launch-14.html" class="menu-left">Методы массивов</a>
            <a href="launch-15.html" class="menu-left">Методы объектов</a>
            <a href="launch-16.html" class="menu-left">Дата и время</a>
            <a href="launch-17.html" class="menu-left">Введение в DOM</a>
        </ul>
        
    </div>
    <div class="block-right">
        <h2 class="menu-title">Объекты</h2>
        <br>
        <p>
            Объекты (object) – это особенный тип в JS. Остальные типы называются примитивными, потому что значения примитивных типов могут быть только простыми значениями, например, строка или число. В объектах хранятся коллекции или более сложные структуры. <br>
            Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств. Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно. <br> <br>
            let user = new Object(); // синтаксис "конструктор объекта" <br> <br>
            let user = {};  // синтаксис "литерал объекта" <br> <br> 
            Обычно используют вариант с фигурными скобками {...}. Такое объявление называют литералом объекта или литеральной нотацией. <br> <br>
            <b>Литералы и свойства</b> <br> <br>
            При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение»: <br> <br>
            let user = {     // объект <br> <br>
              name: "John",  // под ключом "name" хранится значение "John" <br> <br>
              age: 30        // под ключом "age" хранится значение 30 <br> <br>
            }; <br> <br>
            У каждого свойства есть ключ (также называемый «имя» или «идентификатор»). После имени свойства следует двоеточие ":", и затем указывается значение свойства. Если в объекте несколько свойств, то они перечисляются через запятую. <br> <br>
            В объекте user сейчас находятся два свойства: <br> <br>
            1.	Первое свойство с именем "name" и значением "John". <br> <br>
            2.	Второе свойство с именем "age" и значением 30. <br> <br>
            Можно сказать, что наш объект user – это ящик с двумя папками, подписанными «name» и «age». <br> <br>
            Мы можем в любой момент добавить в него новые папки, удалить папки или прочитать содержимое любой папки. <br> <br>
            Для обращения к свойствам используется запись «через точку»: <br> <br>
            // получаем свойства объекта: <br> <br>
            alert( user.name ); // John <br> <br>
            alert( user.age ); // 30 <br> <br>
            Значение может быть любого типа. Давайте добавим свойство с логическим значением: <br> <br>
            user.isAdmin = true; <br> <br>
            Для удаления свойства мы можем использовать оператор delete: <br> <br>
            delete user.age; <br> <br>
            Объект, объявленный через const, может быть изменён. <br> <br>
            Например: <br> <br>
            const user = { <br> <br>
              name: "John" <br> <br>
            };<br> <br>
            user.name = "Pete"; <br> <br>
            alert(user.name); // Pete <br> <br>
            <b>Квадратные скобки</b> <br> <br>
            Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает: <br> <br>
            user.likes birds = true<br> <br>
            JavaScript видит, что мы обращаемся к свойству user.likes, а затем идёт непонятное слово birds. В итоге синтаксическая ошибка. Точка требует, чтобы ключ был именован по правилам именования переменных. То есть не имел пробелов, не начинался с цифры и не содержал специальные символы, кроме $ и _. Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства: <br> <br>
            let user = {}; <br> <br>
            user["likes birds"] = true;<br> <br>
            alert(user["likes birds"]); // true<br> <br>
            
            delete user["likes birds"];<br> <br>
            Сейчас всё в порядке. Обратите внимание, что строка в квадратных скобках заключена в кавычки (подойдёт любой тип кавычек).<br> <br>
            Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:<br> <br>
            let key = "likes birds";<br> <br>
            // то же самое, что и user["likes birds"] = true;<br> <br>
            user[key] = true;<br> <br>
            Здесь переменная key может быть вычислена во время выполнения кода или зависеть от пользовательского ввода. После этого мы используем её для доступа к свойству. Это даёт нам большую гибкость.<br> <br>
            Пример:<br> <br>
            let user = {<br> <br>
              name: "John",<br> <br>
              age: 30<br> <br>
            };<br> <br>
            let key = prompt("Что вы хотите узнать о пользователе?", "name"); <br> <br>
            // доступ к свойству через переменную <br> <br>
            alert( user[key] ); // John (если ввели "name") <br> <br>
            Запись «через точку» такого не позволяет: <br> <br>
            let user = { <br> <br>
              name: "John",<br> <br>
              age: 30<br> <br>
            };<br> <br>
            let key = "name";<br> <br>
            alert( user.key ); // undefined<br> <br>
            Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.<br> <br>
            
            
            скобки дают намного больше возможностей, чем запись через точку. Они позволяют использовать любые имена свойств и переменные, хотя и требуют более громоздких конструкций кода. <br> <br>
            Подведём итог: в большинстве случаев, когда имена свойств известны и просты, используется запись через точку. Если же нам нужно что-то более сложное, то мы используем квадратные скобки. <br> <br>
            <b>Ограничения на имена свойств</b> <br> <br>
            Как мы уже знаем, имя переменной не может совпадать с зарезервированными словами, такими как «for», «let», «return» и т.д. <br> <br>
            Но для свойств объекта такого ограничения нет: <br> <br>
            // эти имена свойств допустимы <br> <br>
            let obj = { <br> <br>
              for: 1, <br> <br>
              let: 2, <br> <br>
              return: 3 <br> <br>
            }; <br> <br>
            alert( obj.for + obj.let + obj.return );  // 6 <br> <br>
            Иными словами, нет никаких ограничений к именам свойств. Они могут быть в виде строк или символов (специальный тип для идентификаторов, который будет рассмотрен позже). <br> <br>
            Все другие типы данных будут автоматически преобразованы к строке. <br> <br>
            Например, если использовать число 0 в качестве ключа, то оно превратится в строку "0": <br> <br>
            let obj = { <br> <br>
              0: "Тест" // то же самое что и "0": "Тест" <br> <br>
            }; <br> <br>
            
            // обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0") <br> <br>
            alert( obj["0"] ); // Тест <br> <br>
            alert( obj[0] ); // Тест (то же свойство)<br> <br>
            Есть небольшой подводный камень, связанный со специальным свойством __proto__. Мы не можем установить его в необъектное значение:<br> <br>
            let obj = {};<br> <br>
            obj.__proto__ = 5; // присвоим число<br> <br>
            alert(obj.__proto__); // [object Object], значение - это объект, т.е. не то, что мы ожидали<br> <br>
            Как мы видим, присвоение примитивного значения 5 игнорируется.<br> <br>
            Мы более подробно исследуем особенности свойства __proto__ в следующих главах Прототипное наследование, а также предложим способы исправления такого поведения.<br> <br>
            <b>Проверка существования свойства, оператор «in»</b> <br> <br>
            В отличие от многих других языков, особенность JavaScript-объектов в том, что можно получить доступ к любому свойству. Даже если свойства не существует – ошибки не будет! <br> <br>
            При обращении к свойству, которого нет, возвращается undefined. Это позволяет просто проверить существование свойства:<br> <br>
            let user = {}; <br> <br>
            alert( user.noSuchProperty === undefined ); // true означает "свойства нет"<br> <br>
            Также существует специальный оператор "in" для проверки существования свойства в объекте.<br> <br>
            Синтаксис оператора:<br> <br>
            "key" in object<br> <br>
            Пример:<br> <br>
            let user = { name: "John", age: 30 };<br> <br>
            alert( "age" in user ); // true, user.age существует<br> <br>
            alert( "blabla" in user ); // false, user.blabla не существует<br> <br>
            <b>Сравнение по ссылке</b><br> <br>
            Два объекта равны только в том случае, если это один и тот же объект.<br> <br>
            Например, здесь a и b ссылаются на один и тот же объект, поэтому они равны:<br> <br>
            let a = {};<br> <br>
            let b = a; // копирование по ссылке<br> <br>
            alert( a == b ); // true, обе переменные ссылаются на один и тот же объект<br> <br>
            alert( a === b ); // true<br> <br>
            И здесь два независимых объекта не равны, даже если они выглядят одинаково (оба пусты):<br> <br>
            let a = {};<br> <br>
            let b = {}; // два независимых объекта<br> <br>
            alert( a == b ); // false<br> <br>
            Для сравнений типа obj1 > obj2 или для сравнения с примитивом obj == 5 объекты преобразуются в примитивы. Очень скоро мы изучим, как работают преобразования объектов, но, по правде говоря, такие сравнения требуются очень редко и обычно они появляются в результате ошибок программиста.<br> <br>
            <b>Клонирование и объединение, Object.assign</b><br> <br>
            Копирование объектной переменной создаёт ещё одну ссылку на тот же объект.<br> <br>
            Если нужно продублировать объект, то  нужно создать новый объект и воспроизвести структуру существующего, перебрав его свойства и скопировав их на примитивном уровне.<br> <br>
            Пример:<br> <br>
            let user = {<br> <br>
              name: "John",<br> <br>
              age: 30<br> <br>
            };<br> <br>
            let clone = {}; // новый пустой объект<br> <br>
            // давайте скопируем все свойства user в него<br> <br>
            for (let key in user) {<br> <br>
              clone[key] = user[key];<br> <br>
            }<br> <br>
            // теперь clone это полностью независимый объект с тем же содержимым<br> <br>
            clone.name = "Pete"; // изменим в нём данные<br> <br>
            alert( user.name ); // все ещё John в первоначальном объекте<br> <br>
            Можем использовать для этого метод Object.assign.<br> <br>
            Синтаксис:<br> <br>
            Object.assign(dest, [src1, src2, src3...])<br> <br>
            •	Первый аргумент dest — целевой объект.<br> <br>
            •	Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами<br> <br>
            •	Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.<br> <br>
            •	Возвращает объект dest. <br> <br>
            Можем использовать его для объединения нескольких объектов в один:<br> <br>
            let user = { name: "John" };<br> <br>
            let permissions1 = { canView: true };<br> <br>
            let permissions2 = { canEdit: true };<br> <br>
            // копируем все свойства из permissions1 и permissions2 в user<br> <br>
            Object.assign(user, permissions1, permissions2);<br> <br>
            // теперь user = { name: "John", canView: true, canEdit: true }<br> <br>
            Если скопированное имя свойства уже существует, оно будет перезаписано:<br> <br>
            let user = { name: "John" };<br> <br>
            Object.assign(user, { name: "Pete" });<br> <br>
            alert(user.name); // теперь user = { name: "Pete" }<br> <br>
            Можем использовать Object.assign для замены цикла for..in для простого клонирования:<br> <br>
            let user = {<br> <br>
              name: "John",<br> <br>
              age: 30<br> <br>
            };<br> <br>
            let clone = Object.assign({}, user);<br> <br>
            Он копирует все свойства user в пустой объект и возвращает его.<br> <br>
            Существуют и другие методы клонирования объекта. Например, с использованием оператора расширения clone = {...user}. <br> <br>
            <b>Вложенное клонирование</b><br> <br>
            Свойства могут быть и ссылками на другие объекты. <br> <br>
            Например, есть объект:<br> <br>
            let user = {<br> <br>
              name: "John",<br> <br>
              sizes: {<br> <br>
                height: 182,<br> <br>
                width: 50<br> <br>
              }<br> <br>
            };<br> <br>
            alert( user.sizes.height ); // 182<br> <br>
            Теперь недостаточно просто скопировать clone.sizes = user.sizes, потому что user.sizes – это объект, он будет скопирован по ссылке. Таким образом, clone и user будут иметь общий объект sizes:<br> <br>
            let user = {<br> <br>
              name: "John",<br> <br>
              sizes: {<br> <br>
                height: 182,<br> <br>
                width: 50<br> <br>
              }<br> <br>
            };<br> <br>
            let clone = Object.assign({}, user);<br> <br>
            alert( user.sizes === clone.sizes ); // true, тот же объект<br> <br>
            // user и clone обладают общим свойством sizes<br> <br>
            user.sizes.width++;       // изменяем свойства в первом объекте<br> <br>
            alert(clone.sizes.width); // 51, видим результат в другом<br> <br>
            Чтобы исправить это, необходимо использовать цикл клонирования, который проверяет каждое значение user[key] и, если это объект, тогда также копирует его структуру. Это называется «глубоким клонированием».<br> <br>
            Мы можем реализовать глубокое клонирование, используя рекурсию. <br> <br>
            Также можно использовать глобальный метод structuredClone(), который позволяет сделать полную копию объекта. <br> <br>
            
        </p>
    </div>
    </main>
    <footer class="block-info-4">
        <div class="block">
            <p>8-800-700-93-29</p>
            <p class="zvonok">Звонок по России бесплатный</p>
            <a href="#"><img class="telegram" src="../img/icons8-телеграмма-app-48.png" alt=""></a>
            <a href="#"><img class="img-vk" src="../img/icons8-vk-48.png" alt=""></a>
        </div>
    </footer>
</body>
</html>